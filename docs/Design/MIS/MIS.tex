\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red, % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}

\newcommand{\progname}{Sun Catcher}

\begin{document}

\title{Module Interface Specification for \progname}

\author{Sharon (Yu-Shiuan) Wu}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
2019/11/25 & 1.0 & First Version\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/sharyuwu/optimum-tilt-of-solar-panels/blob/master/docs/SRS/SRS.pdf}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for \progname
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/sharyuwu/optimum-tilt-of-solar-panels}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in  (-$\infty$,
$\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1,
$\infty$) \\
real & $\mathbb{R}$ & any number in  (-$\infty$, $\infty$)\\
bool &$\mathbb{B}$ & a statement of True or False\\


\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences,
strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.



\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this
project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding Module} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding
 Module}& Control Module\\
& Input Parameters Module\\
& Input Verification Module\\
& Output Parameters Module\\
& Read File Module\\
& Solar Energy Absorption Module\\
& Optimum Tilt Angle Module\\
& Sun Intensity Equation Module\\
& Zenith Angle Equation Module\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision Module} 
& Day Duration ADT Module\\
& Table-layout Module\\
& Sun Catcher Type 
Module\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage


\section{MIS of Control Module} \label{ModuleC} 

\subsection{Module}
Control

\subsection{Uses}
InputPara\ref{ModuleIP}\\
InputVer\ref{ModuleIV}\\
OutputPara\ref{ModuleOP}\\
TiltAng\ref{ModuleTA}\\
Energy\ref{ModuleE}\\
SunInten\ref{ModuleSI}\\
ZenithAng\ref{ModuleZA}\\
ReadFile\ref{ModuleR}

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
mian & - & - & - \\

\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
dayS: DayT\\
dayE: DayT


\subsubsection{Environment Variables}


\subsubsection{Assumptions}


\subsubsection{ Access Routine Semantics}

\noindent  main ( ):

\begin{itemize}
\item transition: Implement the InputPara and  the environment variables for Output by following steps.

Get ($\Phi_P$: DegreeT, $P_{A_{\text{h}}}$: real, $P_{A_{\text{w}}}$: real, $\mathit{year}_\text{Start}$: natural number, $\mathit{month}_\text{Start}$: natural number, $\mathit{day}_\text{Start}$: natural number, $\mathit{year}_\text{End}$: natural number, $\mathit{month}_\text{End}$: natural number, $\mathit{day}_\text{End}$: natural number) and (filename: string ) from users' input.\\

dayS := $\langle$ $\mathit{day}_\text{Start}$, $\mathit{month}_\text{Start}$, $\mathit{year}_\text{Start}$ $\rangle$ \\
dayE :=  $\langle$ $\mathit{day}_\text{End}$, $\mathit{month}_\text{End}$, $\mathit{year}_\text{End}$ $\rangle$ \\

load\_anale\_data (filename)\\
InputPara.init ( )\\

$\#$ Verify the input values using Input Verfication Module\\
verified ($\Phi_P$, $P_{A_{\text{h}}}$, $P_{A_{\text{w}}}$, dayS, dayE )\\

$\#$ Get the zenith angle between dayS and
dayE\\
$\theta_{S_{\text{date}}}$ = getzen ( )\\

$\#$ Get the optimum tilt angle using $\theta_{S_{\text{date}}}$\\
setilt ( $\theta_{S_{\text{date}}}$ )\\
$\theta_{T}$ = getilt ( )\\


$\#$ Get the estimated solar absorption using Optimum Tilt Angle Module\\
setenergy ($P_{A_{\text{w}}}$, $P_{A_{\text{h}}}$, getmaxInten ( ), $\theta_{S_{\text{date}}}$ )\\
$P_{E}$ = getavenergy ( )\\

$\#$ Output $P_{E}$ and $\theta_{T}$ to the Output paramaters Module\\
addresult ($\theta_{T}$, $P_{E}$ )\\

$\#$ Display the output values on the screen using the Table-layout Module\\
setable ( getresult ( ) )\\
display ( )

\end{itemize}



\section{Sun Catcher Type Module} \label{ModuleSCTM} 

\subsection{Module}
SunCatTy

\subsection{Uses}

N/A\\

\subsection{Exported Types}

DegreeT = $\mathbb{R}$\\
DayT = a tuple of (d:$\mathbb{N}$, m:$\mathbb{N}$, y:$\mathbb{N}$)\\
AnalemmaT = a tuple of (x: $\mathbb{R}$ ,y: $\mathbb{R}$, z: $\mathbb{R}$)\\

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A\\

\subsubsection{Exported Access Programs}
N/A\\

\subsection{Semantics}
N/A\\
\subsubsection{State Variables}
N/A\\

\subsubsection{Environment Variables}

N/A\\

\subsubsection{Assumptions}
For DayT the day will always lie between 1 and 31, the month will always lie between 1 and 12, and year will always be greater than 1.

\section{Day Duration ADT Module} \label{ModuleADTD} 

\subsection{Template Module}
DayDurTy

\subsection{Uses}

SunCatTy\ref{ModuleSCTM} \\

\subsection{Exported Types}

DayDurT = ?\\

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{5cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
new DayDurT& a tuple of (DayT, DayT)  & DayDurT & invalid\_argument \\
getdurlist &  -  & a sequence of integer & - \\

\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
dayS : DayT\\
dayE : DayT\\
daduraL: a sequence of integer\\
dateL: a sequence of DayT\\
\subsubsection{Environment Variables}

N/A\\

\subsubsection{Assumptions}
In  getdiff (day1, day2), assume that day 2 is always greater than day 1.

\subsubsection{ Access Routine Semantics}

\noindent  new DayDurT (s,e):
\begin{itemize}
\item transition:  dayS, dayE, periheD.d,  periheD.m := s, e, 21, 12;\\

dateL := $\|$ (s = e $\Rightarrow$ $\langle$ e $\rangle$ $|$ otherwise $\Rightarrow$ $\langle$ s, setlist (getnext ( )) $\rangle$) 

\item output: out := self
\item exception: exc := (s $>$e $\Rightarrow$ invalid\_argument )
\end{itemize}

\noindent  getdurlist ( ):
\begin{itemize}
\item transition: daduraL := $\|$ (d: DayT $|$ d $\in$ dateL  $\bullet$ [ Countdiff (perihelion ( d ), d) ]
\item output: out := daduraL
\item exception:
\end{itemize}


\subsubsection{Local Functions}
setlist : DayT $\rightarrow $ a sequence of DayT\\
setlist ( day ): = $\|$ (day = dayE $\Rightarrow$ $\langle$ dayE $\rangle$ $|$ day $<$ dayE $\Rightarrow$ [ day, setlist (getnext (day,  dayE)) ]) \\

getnext : DayT $\times$ DayT $\rightarrow $ DayT\\
getnext (d1, d2) := (d1 $<$ d2 $\Rightarrow$ The next day of d1 according to the calendar $|$ otherwise $\Rightarrow$ dateL [0] )\\

perihelion : DayT $\rightarrow $ DayT\\
perihelion (day) :=  (day.m = 12 $	\wedge$ day.d $\geq	$ 21 $\Rightarrow$  day.y $|$ otherwise $\Rightarrow$  day.y - 1)\\

Countdiff : DayT $\times$ DayT $\rightarrow $ integer\\
Countdiff (day1, day2) := + (day1 = day2 $\Rightarrow$ 0 $|$ otherwise $\Rightarrow$ Countdiff (getnext (day1,day2), day2) + 1 )


\section{MIS of Input Parameters Module} \label{ModuleIP} 

\subsection{Module}
InputPara

\subsection{Uses}
HardH

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
init & - & - & Key\_error \\
getla & - & DegreeT & - \\
getph & - & real & - \\
getpw & - & real & - \\
getds & - & DayT & - \\
getde & - & DayT & - \\


\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
latitude: DegreeT\\
dayS: DayT\\
dayE: DayT\\
panH: real\\
panW real


\subsubsection{Environment Variables}
key: Input variables from keyboard.

\subsubsection{Assumptions}
When users chick the submit bottom from system interface, InputPara.init ( ) implement.

\subsubsection{ Access Routine Semantics}

\noindent  init ( ):
\begin{itemize}
\item transition: Get the values from users' input.\\
latitude, panH, panW, dayS, dayE := HardH.la, HardH.pn, HardH.pw, (HardH.ds, HardH.ms, HardH.ys), (HardH.de, HardH.me, HardH.ye)
\item output:
\item exception: if the data type of captured values do not match with the parameters' data type $\Rightarrow$ Key\_error
\end{itemize}

\noindent  getla ( ):
\begin{itemize}
\item transition: 
\item output: latitude
\item exception: 
\end{itemize}

\noindent  getph ( ):
\begin{itemize}
\item transition: 
\item output: panH
\item exception: 
\end{itemize}

\noindent  getpw ( ):
\begin{itemize}
\item transition: 
\item output: panW
\item exception: 
\end{itemize}

\noindent  getds ( ):
\begin{itemize}
\item transition: 
\item output: dayS
\item exception: 
\end{itemize}

\noindent  getde ( ):
\begin{itemize}
\item transition: 
\item output: dayE
\item exception: 
\end{itemize}

\subsubsection{Local Functions}

\section{MIS of Input Verfication Module} \label{ModuleIV} 

\subsection{Module}
InputVer

\subsection{Uses}
InputPara\ref{ModuleIP}

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{5cm} p{2cm} p{5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
verified & DegreeT, real, real, DayT, DayT, & - & invaild\_lan, invaild\_pan, invaild\_day \\
\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}



\subsubsection{Environment Variables}


\subsubsection{Assumptions}
The input values is input from InputPara


\subsubsection{ Access Routine Semantics}

\noindent  verified (lan, ph, pw, ds, de):
\begin{itemize}
\item transition: 

\item output:
\item exception: exc := 
(lan $>	$ 90 $\wedge$ lan $<$ - 90 $\Rightarrow$ invaild\_lan
$|$
ph $<$ 0 $\wedge$ pw $<$ 0 $\Rightarrow$ invaild\_pan
$|$
if ds and de is a invalid date in Gregorian calendar $\Rightarrow$ invaild\_day)
\end{itemize}


\subsubsection{Local Functions}

\section{MIS of Output Parameters Module} \label{ModuleOP} 

\subsection{Module}
OutputPara

\subsection{Uses}
Table\ref{ModuleT}\\

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{5cm} p{5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
init & - & - & - \\
addresult &  DegreeT, real & - & - \\
getresult & - & a sequence of a tulple of ( DegreeT, real, integer) & - \\



\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
resultL: a sequence of a tulple of ( t: DegreeT, e: real, diff: integer)\\


\subsubsection{Environment Variables}


\subsubsection{Assumptions}
OutputPara.init ( ) always implement before any export access programs in output parameters module.
OutputPara.init ( ) will only be called once.

\subsubsection{ Access Routine Semantics}

\noindent  init ( ):
\begin{itemize}
\item transition: resultL := $\{ $ $ \}$
\item output:
\item exception: 
\end{itemize}

\noindent  addresult ( angle, energy ):
\begin{itemize}
\item transition: resultL := $\|$ ($|$resultL$|$ = 0 $\Rightarrow$ [ $\langle$ angle, energy, 100 $\rangle$ ] $|$ angle $\notin$ resultL.t $\Rightarrow$ [ $\langle$ angle, energy, getdiff (resultL.e, energy) $\rangle$ ] )
\item output:
\item exception: 
\end{itemize}

\noindent  getresult (  ):
\begin{itemize}
\item transition: 
\item output: out := resultL
\item exception: 
\end{itemize}


\subsubsection{Local Functions}
getdiff : real $\times$ real $\rightarrow$ interger\\
getdiff (e1, e2) =
$\frac{\text{e2}}{\text{e1}}$ $\times$ 100


\section{MIS of Table-layout Module} \label{ModuleT} 

\subsection{Module}
Table\\

\subsection{Uses}
OutputPara\ref{ModuleOP}\\
HardH\\


\subsection{Syntax}

\subsubsection{Exported Constants}

hRow1: "Tilt Angle"
hRow2: "Energy Absorption"
hRow3: "Energy Competition"

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{5cm} p{5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
setable & a sequce of a tuple of ( DegreeT, real, integer ) & - & - \\
display & - & - & - \\

\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

resultL: a sequence of a tulple of ( t: DegreeT, e: real, diff: integer)\\

\subsubsection{Environment Variables}
Output variables will display on the screen.

\subsubsection{Assumptions}


\subsubsection{ Access Routine Semantics}

\noindent  setable (result):
\begin{itemize}
\item transition: resultL := result
\item output:
\item exception: 
\end{itemize}

\noindent  display ( ):
\begin{itemize}
\item transition:
\item output: out := display a table that shows the result on the screen.

The text file has the following format, where the first row following heading: hRow1, denotes the result of optimal tilt angle; the second row following heading, hRow2, denotes the result of estimating energy absorption; and the third row following heading, hRow3, denotes the result of different energy absorption between resultL.e [ 0 ] and resultL.e [ 1.. $|$ resultL$|$ ] followed by a symbol $\%$


\begin{center}
\begin{tabular}{p{4.5cm}|p{4cm}|p{1cm}|p{5cm}}

\hline 
Tilt Angle & resultL.t [ 0 ] & ...  & resultL.t [ $|$ resultL$|$ ] \\
\hline 
Energy Absorption & resultL.e [ 0 ] & ...  & resultL.e [ $|$ resultL$|$ ] \\
\hline 
Energy Competition & resultL.diff [ 0 ] $\%$    & ...     & resultL.diff [ $|$ resultL$|$ ] $\%$    \\
\hline
\end{tabular}
\end{center}

\item exception: 
\end{itemize}


\subsubsection{Local Functions}


\section{MIS of Optimum Tilt Angle Module} \label{ModuleTA} \wss{Use labels for
  cross-referencing}

\subsection{Module}
TitleAng
\wss{Short name for the module}

\subsection{Uses}
SunInten\ref{ModuleSI}\\
ZenithAng\ref{ModuleZA}\\

\subsection{Syntax}


\subsubsection{Exported Constants}

$I_{S}$ := 1.35\\


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
setilt &  a sequence of DegreeT  & -  & - \\
getilt &  -  & DegreeT & - \\
getmaxInten &  -  & real & out\_empty \\


\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

sunIn: real\\
zenithL: a sequence of DegreeT\\
maxsunIn: a tuple of (i: real, d: DegreeT)\\

\wss{Not all modules will have state variables.  State variables give the module  a memory.}

\subsubsection{Environment Variables}

N/A
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}


\wss{Try to minimize assumptions and anticipate programmer errors via
exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg} setilt( zen ):
\begin{itemize}
\item transition: sunIn, zenithL, maxsunIn := SunInten.sum ($I_{S}$, zen),   zen, $\langle$ 0, 0 $\rangle$
\item output: 
\item exception: 
\end{itemize}


\noindent \wss{accessProg} getilt ( ):
\begin{itemize}
\item transition: maxsunIn := (j: integer $|$ j $\in$ [0.. $|$zenithL$|$] $\bullet$ j = 0 $\Rightarrow$  $\langle$ SunInten.single (sunIn, zenithL [ 0 ]), zenithL [ 0 ] $\rangle$ $|$ ifMax (maxsunIn.i, SunInten.single (sunIn, zenithL [ j ])) $\neq$ maxsunIn.i $\Rightarrow$  $\langle$ SunInten.single (sunIn, zenithL [ j ]), zenithL [ j ]$\rangle$ )
 
\item output: out := maxsunIn.d
\item exception: 
\end{itemize}

\noindent getmaxInten ( ):
\begin{itemize}
\item transition:
\item output: SunInten.single (sunIn, maxsunIn.d )
\item exception: exp := maxsunIn.i = 0 $\wedge$ maxsunIn.d $\Rightarrow$ out\_empty
\end{itemize}


\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

ifMax: real $\times$ real $\rightarrow$ real\\
ifMax(x, y) = (x $\geq$ y $\Rightarrow$ x $|$ otherwise $\Rightarrow$ y )\\


\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}



\section{MIS of Solar Energy Absorption Module} \label{ModuleE} 

\subsection{Module}
Energy

\subsection{Uses}
InputPara\ref{ModuleIP}\\
ZenithAng\ref{ModuleZA}\\ 
TiltAng\ref{ModuleTA}

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{5cm} p{4cm} p{1cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
setenergy & real, real, DegreeT, a sequence of DegreeT & - & - \\
getavenergy & - & real & - \\

\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

energyL: a sequence of real\\

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}
ZenithAngle has been fully implement before implement Energy.init ( ).\\
Energy.init ( ) is called first before any other exported access programs.\\


\subsubsection{ Access Routine Semantics}

\noindent  setenergy ( pw, ph, maxinten, zen ):
\begin{itemize}
\item transition:
energyL := getenergy ( getsunIn ( zen, maxinten ),pw, ph)
\item output:
 
\item exception: 
\end{itemize}

\noindent  getavenergy ( ):
\begin{itemize}
\item transition: 
\item output: out := + (i: integer $|$ i $\in$ [0.. $|$energyL$|$] $\bullet$  energyL[ i ]) / $|$energyL$|$
\item exception: 
\end{itemize}


\subsubsection{Local Functions}
getsunIn: a sequence of DegreeT $\rightarrow$ a sequence of real\\
getsunIn (z, maxinten) = $\|$ (i: integer $|$ i $\in$ [0.. $|$z$|$] $\bullet$ [ SunInten.single(maxinten, z[ i ]) ])\\

getenergy: a sequence of real $\times$ real $\times$ real $\rightarrow$ a sequence of real\\
getenergy (e, pw, ph) =  $\|$ (i: integer $|$ i $\in$ [0.. $|$e$|$] $\bullet$ [ pw $\times$ ph $\times$ 18.7 $\times$ 0.75 $\times$ e [ i ] ])


\section{MIS of Sun Intensity Equation Module} \label{ModuleSI} 
\wss{Use labels for cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hyperlinks  to external documents.}

\subsection{Module}
SunInten

\subsection{Uses}
ZenithAngle\ref{ModuleZA}

\subsection{Syntax}

\subsubsection{Exported Constants}
$I_{S}$ := 1.35\\

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{5cm} p{3cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
sum & real, a sequence of DegreeT & real & sequence\_empty \\
single & real, DegreeT & real & - \\

\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}


\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

\subsubsection{ Access Routine Semantics}

\noindent sum ( e, z ):
\begin{itemize}
\item output: out := + (i: integer $|$ i $\in$ [0.. $|$z$|$] $\bullet$ 
\begin{center}\large
$I_{S} \cdot \frac{1.00}{e}^{sec(z [ i ])} $)
\end{center}
\item exception: exc := $|$z$|$ = 0 $\Rightarrow$ sequence\_empty
\end{itemize}

\noindent single (e, z):
\begin{itemize}
\item output: out := 
\begin{center}\large
$I_{S} \cdot \frac{1.00}{e}^{sec(z)} $
\end{center}
\item exception: 
\end{itemize}

\subsubsection{Local Functions}


\section{MIS of Zenith Angle Equation Module} \label{ModuleZA} 

\subsection{Module}
ZenithAng


\subsection{Uses}
DayDurTy\ref{ModuleADTD}\\
SunCatTy\ref{ModuleSCTM}

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{5cm} p{4cm} p{1cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
setzen & AnalammaT, real, DayT, DayT & -  & -\\
getzen &  -  & a sequence of DegreeT & sequence\_empty \\

\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

decS: a sequence of DegreeT\\
day: DayDurTy\\
latitude: real\\
analeL: a sequence of AnalemmaT

\subsubsection{Environment Variables}




\subsubsection{Assumptions}
Read File Module will always be implemented before Zenith angle Module.\\
InputPara Module will always be implemented before Zenith angle Module.\\
ZenithAng.setzen is called before any other access program.\\
ZenithAng.setzen is called by the Read File Module.


\subsubsection{ Access Routine Semantics}


\noindent setzen (a, lan, ds, de):
\begin{itemize}
\item transition: analeL := $\|$ (i: integer $|$ i $\in$ [ 0..$|$a$|$ ] $\bullet	$ [ $\langle$ a.x [ i ], a.y [ i ], a.z [ i ] $\rangle$] )\\
day := new DayDurT (ds, de)\\
latitude := lan\\
decS := getdec (day.getdurlist)
\item output: 
\item exception: 
\end{itemize}

\noindent  getzen ( ):
\begin{itemize}
\item transition:

\item output: out := $\|$ (i: integer $|$ i $\in$ [0.. $|$decS$|$] $\bullet$ latitude $\times$ decS [ i ] $\geq$ 0 $\Rightarrow$ [ latitude - decS [  i ] ] $|$ otherwise $\Rightarrow$ [ latitude + decS [ i ] ])
\item exception: $|$decS$|$ = 0 $\Rightarrow$ sequence\_empty
\end{itemize}


\subsubsection{Local Functions}
getdec : a sequence of integer $\rightarrow$ a sequence of DegreeT\\
getdec (d) := $\|$ (i: integer $|$ i $\in$ [0.. $|$d$|$] $\bullet$ 
\begin{center}\large
[ $\arcsin \frac{analeL.z [d[ i ] ]}{ \sqrt{analeL.x^2 [ d[ i ] ] + analeL.y^2 [ dayL[ i ] ] + analeL.z^2 [ d[ i ] ]}}) $]
\end{center}

\newpage

\section{MIS of Read File Module} \label{ModuleR} 

\subsection{Module}
ReadFile


\subsection{Uses}
ZenithAng\ref{ModuleZA}


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{3cm} p{3cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
load\_anale\_data & string & - & -\\


\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}



\subsubsection{Environment Variables}

anale\_data: File listing Analemma data


\subsubsection{Assumptions}
The input file will match the given specification.
ReadFile.load\_anale\_data(s) is called by the Input Parameters Module

\subsubsection{ Access Routine Semantics}


\noindent  load\_anale\_data ( s ):
\begin{itemize}
\item transition: read data from the file anale\_data associated with the string s. Use
this data to update the state of the ZenithAng module. load\_anale\_data ( s ) will first initialize ZenithAng (ZenithAng.setzen (anale, lan, ds, de )) before populating ZenithAng with analemma data that follows the types in SunCatTy.

The text file has the following format, where x\_i, y\_i z\_i denotes the vector that locates
Earth relative to the Sun on the day i since perihelion.

All data values in a row are separated by commas. Rows are separated by a new line. The data shown below is for a total of 366 days.
\begin{center}
x\_0,   y\_0,   z\_0\\
x\_1,   y\_1,   z\_1\\
x\_2,   y\_2,   z\_2\\
.\\
.\\
.\\
x\_365,   y\_365,   z\_365\\
\end{center}
\item output: 
\item exception: 
\end{itemize}
 

\subsubsection{Local Functions}


\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}