\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red, % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}

\newcommand{\progname}{Sun Catcher}

\begin{document}

\title{Module Interface Specification for \progname}

\author{Sharon (Yu-Shiuan) Wu}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{...}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in  (-$\infty$,
$\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1,
$\infty$) \\
real & $\mathbb{R}$ & any number in  (-$\infty$, $\infty$)\\
bool &$\mathbb{B}$ & a statement of True or False\\


\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences,
strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.



\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this
project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding Module} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding
 Module}& Control Module\\
& Input Parameters Module\\
& Input Verify Module\\
& Output Parameters Module\\
& Solar Energy Absorption Module\\
& Optimum Tilt Angle Module\\
& Sun Intensity Equation Module\\
& Zenith Angle Equation Module\\
& Sun Declination Module\\
& Days Module\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision Module} 
& Count days Module\\
& Table-layout Module\\
& Sequence Data Structure Module\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage

\section{Sun Catcher Type Module} \label{ModuleSCTM} 

\subsection{Module}
SunCatTy

\subsection{Uses}

N/A\\

\subsection{Exported Types}

DegreeT = $\mathbb{R}$\\
DayT = a tuple of (d:$\mathbb{N}$, m:$\mathbb{N}$, y:$\mathbb{N}$)\\
AnalemmaT = a tuple of (x: $\mathbb{R}$ ,y: $\mathbb{R}$,z: $\mathbb{R}$)\\

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A\\

\subsubsection{Exported Access Programs}
N/A\\

\subsection{Semantics}
N/A\\
\subsubsection{State Variables}
N/A\\

\subsubsection{Environment Variables}

N/A\\

\subsubsection{Assumptions}
For DayT the day will always lie between 1 and 31, the month will always lie between 1 and 12, and year will always be greater than 1.

\section{Day Duration ADT Module} \label{ModuleADTD} 

\subsection{Template Module}
DayDurTy

\subsection{Uses}

SunCatTy\\

\subsection{Exported Types}

DayDurT = ?\\

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{5cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
new DayDurT& a tuple of (DayT, DayT)  & DayDurT & invalid\_argument \\
getdurlist &  -  & a sequence of integer & - \\
setlist  &  DayT  & - & stop\_recursive \\
setperihelion &  DayT  & - & - \\
getnext & - & DayT &  - \\
Countdiff: & a tuple of (DayT, DayT)  & integer & - \\

\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
dayS : DayT\\
dayE : DayT\\
periheD: DayT\\
daduraL: a sequence of integer\\
dateL: a sequence of DayT\\
\subsubsection{Environment Variables}

N/A\\

\subsubsection{Assumptions}
In  getdiff (day1, day2), assume that day 2 is always greater than day 1.

\subsubsection{ Access Routine Semantics}

\noindent  new DayDurT (s,e):
\begin{itemize}
\item transition:  dayS, dayE, periheD.d,  periheD.m := s, e, 21, 12;\\

dateL := $\|$ (s = e $\Rightarrow$ $\langle$ e $\rangle$ $|$ otherwise $\Rightarrow$ $\langle$ s, setlist (getnext ( )) $\rangle$) 

\item output: out := self
\item exception: exc := (s $>$e $\Rightarrow$ invalid\_argument )
\end{itemize}

\noindent  setlist ( day ):
\begin{itemize}
\item transition: dateL := $\|$ (day = dayE $\Rightarrow$ $\langle$ dayE $\rangle$ $|$ otherwise $\Rightarrow$ $\langle$ day, setlist (getnext ( )) $\rangle$) 
\item output: 
\item exception: exc :=  (day = dateL [ 0 ] $\Rightarrow$ stop\_recursive)
\end{itemize}

\noindent  getdurlist ( ):
\begin{itemize}
\item transition: daduraL := $\|$ (d: DayT $|$ d $\in$ dateL  $\bullet$ $\langle$ Countdiff (periheD, d) $\rangle$ where setperihelion (d)) 
\item output: out := daduraL
\item exception:
\end{itemize}

\noindent setperihelion (day):
\begin{itemize}
\item transition: periheD.y :=  (day.m = 12 $	\wedge$ day.d $\geq	$ 21 $\Rightarrow$  day.y $|$ otherwise $\Rightarrow$  day.y - 1)
\item output: 
\item exception: 
\end{itemize}

\noindent Countdiff (day1, day2):
\begin{itemize}
\item transition:
\item output: out := + (day1 = day2 $\Rightarrow$ 0 $|$ otherwise $\Rightarrow$ Countdiff (getnext (day1), day2) + 1)
\item exception: 
\end{itemize}


\noindent  getnext (  ):
\begin{itemize}
\item transition: 
\item output: dayS := (dayS $<$ dayE $\Rightarrow$ The next day of dayS according to the calendar $|$ otherwise $\Rightarrow$ dateL [0] )
\item exception: 
\end{itemize}


\section{MIS of Input Parameters Module} \label{ModuleIP} 

\subsection{Module}
InputPara

\subsection{Uses}
HardH

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
init & - & - & Key\_error \\
getla & - & DegreeT & - \\
getph & - & real & - \\
getpw & - & real & - \\
getds & - & DayT & - \\
getde & - & DayT & - \\


\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
latitude: DegreeT\\
dayS: DayT\\
dayE: DayT\\
panH: real\\
panW real


\subsubsection{Environment Variables}
key: Input variables from keyboard.

\subsubsection{Assumptions}
When users chick the submit bottom from system interface, InputPara.init ( ) implement.

\subsubsection{ Access Routine Semantics}

\noindent  init ( ):
\begin{itemize}
\item transition: latitude, panH, panW, dayS, dayE := HardH.la, HardH.pn, HardH.pw, (HardH.ds, HardH.ms, HardH.ys), (HardH.de, HardH.me, HardH.ye)
\item output:
\item exception: 
\end{itemize}

\noindent  getla ( ):
\begin{itemize}
\item transition: 
\item output: latitude
\item exception: 
\end{itemize}

\noindent  getph ( ):
\begin{itemize}
\item transition: 
\item output: panH
\item exception: 
\end{itemize}

\noindent  getpw ( ):
\begin{itemize}
\item transition: 
\item output: panW
\item exception: 
\end{itemize}

\noindent  getds ( ):
\begin{itemize}
\item transition: 
\item output: dayS
\item exception: 
\end{itemize}

\noindent  getde ( ):
\begin{itemize}
\item transition: 
\item output: dayE
\item exception: 
\end{itemize}

\subsubsection{Local Functions}

\section{MIS of Input Verify Module} \label{ModuleIV} 

\subsection{Module}
InputVer

\subsection{Uses}
InputPara

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
init & - & - & - \\
getverlan & - & bool & - \\
getverpan & - & bool & - \\
getverday & - & bool & - \\
\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
latitude: DegreeT\\
dayS: DayT\\
dayE: DayT\\
panH: real\\
panW real


\subsubsection{Environment Variables}


\subsubsection{Assumptions}
InputPara will always implement before InputVer


\subsubsection{ Access Routine Semantics}

\noindent  init ( ):
\begin{itemize}
\item transition: latitude,panH, panW, dayS, dayE := InputPara.la, InputPara.ph, InputPara.pw,  InputPara.ds, InputPara.de
\item output:
\item exception: 
\end{itemize}

\noindent  getverlan ( ):
\begin{itemize}
\item transition: 
\item output: out := (latitude $\leq	$ 90 $\wedge$ latitude $\geq$ - 90 $\Rightarrow	$ True $|$ otherwise $\Rightarrow	$ False)
\item exception: 
\end{itemize}

\noindent  getverpan ( ):
\begin{itemize}
\item transition: 
\item output: out := (panH $>$ 0 $\wedge$ panW $>$ 0 $\Rightarrow	$ True $|$ otherwise $\Rightarrow	$ False)
\item exception: 
\end{itemize}

\noindent  getverday ( ):
\begin{itemize}
\item transition: 
\item output: out := ( if dayS and dayE is a valid date in Gregorian calendar $\Rightarrow	$ True $|$ otherwise $\Rightarrow	$ False)
\item exception: 
\end{itemize}


\subsubsection{Local Functions}

\section{MIS of Output Parameters Module} \label{ModuleIP} 

\subsection{Module}
OutputPara

\subsection{Uses}
Table\\

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{5cm} p{5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
init & - & - & - \\
addresult & a tulple of ( DegreeT, real, integer) & - & - \\
getresult & - & a sequence of a tulple of ( DegreeT, real, integer) & - \\
getdiff & real, real & integer & - \\


\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
resultL: a sequence of a tulple of ( t: DegreeT, e: real, diff: integer)\\


\subsubsection{Environment Variables}


\subsubsection{Assumptions}


\subsubsection{ Access Routine Semantics}

\noindent  init ( ):
\begin{itemize}
\item transition: resultL := $\{ $ $ \}$
\item output:
\item exception: 
\end{itemize}

\noindent  addresult ( angle, energy ):
\begin{itemize}
\item transition: resultL := $\|$ ($|$resultL$|$ = 0 $\Rightarrow$ $\langle$ ( angle, energy, 100 )  $\rangle$ $|$ angle $\notin$ resultL.t $\Rightarrow$ $\langle$ ( angle, energy, getdiff (resultL.e, energy) )  $\rangle$ )
\item output:
\item exception: 
\end{itemize}

\noindent  getresult (  ):
\begin{itemize}
\item transition: 
\item output: out := resultL
\item exception: 
\end{itemize}

\noindent  getdiff ( e1, e2 ):
\begin{itemize}
\item transition: 
\item output: out :=
\large
$\frac{\text{e2}}{\text{e1}}$ $\times$ 100

\item exception: 
\end{itemize}

\subsubsection{Local Functions}

\section{MIS of Table-layout Module} \label{ModuleTI} 

\subsection{Module}
Table\\

\subsection{Uses}
OutputPara\\
HardH\\


\subsection{Syntax}

\subsubsection{Exported Constants}

hRow1: "Tilt Angle"
hRow2: "Energy Absorption"
hRow3: "Energy Competition"

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{5cm} p{5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
init & - & - & - \\
display & - & - & - \\

\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

resultL: a sequence of a tulple of ( t: DegreeT, e: real, diff: integer)\\

\subsubsection{Environment Variables}
Output variables will display on the screen.

\subsubsection{Assumptions}


\subsubsection{ Access Routine Semantics}

\noindent  init ( ):
\begin{itemize}
\item transition: resultL := OutPara.getresult ( )
\item output:
\item exception: 
\end{itemize}

\noindent  display ( ):
\begin{itemize}
\item transition:
\item output: out := display a table that shows the result on the screen.

The text file has the following format, where the first row following heading: hRow1, denotes the result of optimal tilt angle; the second row following heading, hRow2, denotes the result of estimating energy absorption; and the third row following heading, hRow3, denotes the result of different energy absorption between resultL.e [ 0 ] and resultL.e [ 1.. $|$ resultL$|$ ] followed by a symbol $\%$


\begin{center}
\begin{tabular}{p{4.5cm}|p{4cm}|p{1cm}|p{5cm}}

\hline 
Tilt Angle & resultL.t [ 0 ] & ...  & resultL.t [ $|$ resultL$|$ ] \\
\hline 
Energy Absorption & resultL.e [ 0 ] & ...  & resultL.e [ $|$ resultL$|$ ] \\
\hline 
Energy Competition & resultL.diff [ 0 ] $\%$    & ...     & resultL.diff [ $|$ resultL$|$ ] $\%$    \\
\hline
\end{tabular}
\end{center}

\item exception: 
\end{itemize}


\subsubsection{Local Functions}


\section{MIS of Optimum Tilt Angle Module} \label{ModuleOT} \wss{Use labels for
  cross-referencing}

\subsection{Module}
TitleAng
\wss{Short name for the module}

\subsection{Uses}
SunInten\\
ZenithAng\\

\subsection{Syntax}


\subsubsection{Exported Constants}

$I_{S}$ := 1.35\\


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
init &  -  & -  & - \\
getilt &  -  & DegreeT & - \\



\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

sunIn: real\\
zenithL: a sequence of DegreeT\\
maxsunIn: a tuple of (i: real, d: DegreeT)\\

\wss{Not all modules will have state variables.  State variables give the module  a memory.}

\subsubsection{Environment Variables}

N/A
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}


\wss{Try to minimize assumptions and anticipate programmer errors via
exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg} init( ):
\begin{itemize}
\item transition: sunIn, zenithL,maxsunIn.i, maxsunIn.d := SunInten.sum($I_{S}$), ZenithAng.getzen ( ),  
\item output: 
\item exception: 
\end{itemize}


\noindent \wss{accessProg} getilt ( ):
\begin{itemize}
\item transition: maxsunIn := (j: integer $|$ j $\in$ [0.. $|$zenithL$|$] $\bullet$ j = 0 $\Rightarrow$  (SunInten.single (sunIn, zenithL [ 0 ]), zenithL [ 0 ]) $|$ ifMax (maxsunIn.i, SunInten.single (sunIn, zenithL [ j ])) $\neq$ maxsunIn.i $\Rightarrow$  (SunInten.single (sunIn, zenithL [ j ]), zenithL [ j ]))
 
\item output: out := maxsunIn.d
\item exception: 
\end{itemize}


\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

ifMax: real $\times$ real $\rightarrow$ real\\
ifMax(x, y) = (x $\geq$ y $\Rightarrow$ x $|$ otherwise $\Rightarrow$ y )

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}



\section{MIS of Solar Energy Absorption Module} \label{ModuleSEA} 

\subsection{Module}
Energy

\subsection{Uses}
InputPara, ZenithAng, TiltAng

\subsection{Syntax}

\subsubsection{Exported Constants}

$I_{S}$ := 1.35\\

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
init & - & - & - \\
getsunIn & - & a sequence of real & - \\
getenergy & - & a sequence of real & - \\
getavenergy & - & real & - \\

\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}
sunInL: a sequence of real\\
energyL: a sequence of real\\
zenL: a sequence of DegreeT\\
maxAng: real\\
avenergy: real\\
panW: real\\
panH: real\\

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}
ZenithAngle has been fully implement before implement Energy.init ( ).\\
Energy.init ( ) is called first before any other exported access programs.\\
Energy.getsunIn ( ) is always called before Energy.getenergy ( ).


\subsubsection{ Access Routine Semantics}

\noindent  init ( ):
\begin{itemize}
\item transition: panW, panH, maxAng, zenL := InputPara.getpw ( ), InputPara.getph ( ), TitleAng.getilt ( ), ZenithAngle.getzen ( )

\item output:
 
\item exception: 
\end{itemize}

\noindent  getsunIn ( ):
\begin{itemize}
\item transition: sunInL := $\|$ (i: integer $|$ i $\in$ [0.. $|$zenL$|$] $\bullet$ $\langle$ SunInten.single(maxAng, zenL[ i ]) $\rangle$)

\item output: out := sunInL
 
\item exception: 
\end{itemize}

\noindent  getenergy ( ):
\begin{itemize}
\item transition: energyL :=  $\|$ (i: integer $|$ i $\in$ [0.. $|$sunInL$|$] $\bullet$ $\langle$ panW $\times$ panH $\times$ 18.7 $\times$ 0.75 $\times$ sunInL [ i ] $\rangle$)
\item output: out := energyL
\item exception: 
\end{itemize}

\noindent  getavenergy ( ):
\begin{itemize}
\item transition: avenergy :=  + (i: integer $|$ i $\in$ [0.. $|$energyL$|$] $\bullet$  energyL[ i ]) / $|$energyL$|$
\item output: out := avenergy
\item exception: 
\end{itemize}


\subsubsection{Local Functions}


\section{MIS of Sun Intensity Equation Module} \label{ModuleSI} 
\wss{Use labels for cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hyperlinks  to external documents.}

\subsection{Module}
SunInten

\subsection{Uses}
ZenithAngle

\subsection{Syntax}

\subsubsection{Exported Constants}
$I_{S}$ := 1.35\\

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{5cm} p{3cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
init & - & - & - \\
sum & real & real & - \\
single & a tuple of (real, DegreeT) & real & - \\

\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

zenL: a sequence of DegreeT\\


\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}
SunInten.init ( ) is called first before any other exported access programs\\
ZenithAngle.init ( ) has been fully implement before implement SunInten.init ( )\\

\subsubsection{ Access Routine Semantics}

\noindent init (  ):
\begin{itemize}
\item transition : zenL := ZenithAng.getzen ( )
\item output: out :
\item exception: 
\end{itemize}

\noindent sum ( i ):
\begin{itemize}
\item output: out := + (i: integer $|$ i $\in$ [0.. $|$zenL$|$] $\bullet$ 
\begin{center}\large
$I_{S} \cdot \frac{1.00}{i}^{sec(zenL [ i ])} $)
\end{center}
\item exception: 
\end{itemize}

\noindent single (i, d):
\begin{itemize}
\item output: out := 
\begin{center}\large
$I_{S} \cdot \frac{1.00}{i}^{sec(d)} $
\end{center}
\item exception: 
\end{itemize}

\subsubsection{Local Functions}


\section{MIS of Zenith Angle Equation Module} \label{ModuleZA} 

\subsection{Module}
ZenithAng


\subsection{Uses}
DayDurTy\\
SunCatTy

\subsection{Syntax}

\subsubsection{Exported Constants}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
init & AnalammaT & -  & -\\
getzen &  -  & a sequence of DegreeT & - \\
getfiltdec &  -  & a sequence of DegreeT & - \\
getdec & - & a sequence of DegreeT & - \\

\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

zenS: a sequence of DegreeT\\
decS: a sequence of DegreeT\\
day: DayDurTy\\
dayL: a sequence of integer\\
latitude: real\\
analeL: a sequence of AnalemmaT

\subsubsection{Environment Variables}




\subsubsection{Assumptions}
Read File Module will always be implemented before Zenith angle Module.\\
InputPara Module will always be implemented before Zenith angle Module.\\
ZenithAng.init ( ) is called before any other access program.\\
ZenithAng.getdec ( ) is called before ZenithAng.getzen ( ).\\

\subsubsection{ Access Routine Semantics}


\noindent \wss{accessProg}init (a):
\begin{itemize}
\item transition: analeL := $\|$ (i: integer $|$ i $\in$ [0.. 365] $\bullet	$ (a.x [ i ], a.y [ i ], a.z [ i ]))\\
day := new DayDurT (InputPara.days, InputPara.daye)\\
dayL, latitude := day.getdurlist, InputPara.getlat\\

\item output: 
\item exception: 
\end{itemize}

\noindent  getzen ( ):
\begin{itemize}
\item transition: zenS := $\|$ (i: integer $|$ i $\in$ [0.. 365] $\bullet$ latitude $\times$ decS [ i ] $\geq$ 0 $\Rightarrow$ $\langle$ latitude - decS [  i ] $\rangle$ $|$ otherwise $\Rightarrow$ $\langle$ latitude + decS [ i ] $\rangle$)

\item output: out := zenS
\item exception: 
\end{itemize}


\noindent  getdec ( ):
\begin{itemize}
\item transition: decS := $\|$ (i: integer $|$ i $\in$ [0.. $|$dayL$|$] $\bullet$ 
\begin{center}\large{
$	\langle \arcsin \frac{analeL.z [dayL[ i ] ]}{ \sqrt{analeL.x^2 [ dayL[ i ] ] + analeL.y^2 [ dayL[ i ] ] + analeL.z^2 [ dayL[ i ] ]}} \rangle$)}
\end{center}
\item output: out := decS
\item exception: 
\end{itemize}

\subsubsection{Local Functions}

\newpage

\section{MIS of Read File Module} \label{ModuleSD} 

\subsection{Module}
ReadFile


\subsection{Uses}
ZenithAng


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{3cm} p{3cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline 
load\_anale\_data & string & - & -\\


\hline
\end{tabular}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}



\subsubsection{Environment Variables}

anale\_data: File listing Analemma data


\subsubsection{Assumptions}
The input file will match the given specification.

\subsubsection{ Access Routine Semantics}


\noindent  load\_anale\_data ( s ):
\begin{itemize}
\item transition: read data from the file anale\_data associated with the string s. Use
this data to update the state of the ZenithAng module. load\_anale\_data ( s ) will first initialize ZenithAng (ZenithAng.init ( )) before populating ZenithAng with analemma data that follows the types in SunCatTy.

The text file has the following format, where x\_i, y\_i z\_i denotes the vector that locates
Earth relative to the Sun on the day i since perihelion.

All data values in a row are separated by commas. Rows are separated by a new line. The data shown below is for a total of 366 days.
\begin{center}
x\_0,   y\_0,   z\_0\\
x\_1,   y\_1,   z\_1\\
x\_2,   y\_2,   z\_2\\
.\\
.\\
.\\
x\_365,   y\_365,   z\_365\\
\end{center}
\item output: 
\item exception: 
\end{itemize}
 

\subsubsection{Local Functions}


\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}